<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>QGIS的数据格式拓展插件开发 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="QGIS的数据格式拓展插件开发 ​        VCT格式是我国在《地理空间数据交换格式》这一国家标准文件中制定的矢量数据交换格式。国产的GIS软件一般有对VCT格式的支持,但是在QGIS等国际GIS上支持较少:sweat::sweat:。我尝试着在QGIS中通过编写C++插件的方式,增加对VCT格式的支持，:thinking::thinking::thinking:途中发现QGIS拓展数据格式">
<meta property="og:type" content="article">
<meta property="og:title" content="QGIS的数据格式拓展插件开发">
<meta property="og:url" content="http://example.com/2020/10/25/QGIS%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8B%93%E5%B1%95%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="QGIS的数据格式拓展插件开发 ​        VCT格式是我国在《地理空间数据交换格式》这一国家标准文件中制定的矢量数据交换格式。国产的GIS软件一般有对VCT格式的支持,但是在QGIS等国际GIS上支持较少:sweat::sweat:。我尝试着在QGIS中通过编写C++插件的方式,增加对VCT格式的支持，:thinking::thinking::thinking:途中发现QGIS拓展数据格式">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2020/10/25/QGIS%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8B%93%E5%B1%95%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/qgsvctprovider.png">
<meta property="og:image" content="http://example.com/2020/10/25/QGIS%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8B%93%E5%B1%95%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/qgsvctfeaturesource.png">
<meta property="og:image" content="http://example.com/2020/10/25/QGIS%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8B%93%E5%B1%95%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/qgsvctfeatureiterator.png">
<meta property="og:image" content="http://example.com/2020/10/25/QGIS%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8B%93%E5%B1%95%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/qgsvctprovidermetadata.png">
<meta property="og:image" content="http://example.com/2020/10/25/QGIS%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8B%93%E5%B1%95%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/qgsvctsourceselectprovider.png">
<meta property="og:image" content="http://example.com/2020/10/25/QGIS%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8B%93%E5%B1%95%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/qgsvctprovidermetadata.png">
<meta property="og:image" content="http://example.com/2020/10/25/QGIS%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8B%93%E5%B1%95%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/qgsvctsourceselect.png">
<meta property="article:published_time" content="2020-10-25T04:17:54.000Z">
<meta property="article:modified_time" content="2020-10-29T11:15:42.260Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2020/10/25/QGIS%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8B%93%E5%B1%95%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/qgsvctprovider.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-QGIS的数据格式拓展插件开发" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/25/QGIS%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8B%93%E5%B1%95%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/" class="article-date">
  <time datetime="2020-10-25T04:17:54.000Z" itemprop="datePublished">2020-10-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      QGIS的数据格式拓展插件开发
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong><center><font size=10>QGIS的数据格式拓展插件开发</font></center></strong></p>
<p>​        VCT格式是我国在《地理空间数据交换格式》这一国家标准文件中制定的矢量数据交换格式。国产的GIS软件一般有对VCT格式的支持,但是在QGIS等国际GIS上支持较少:sweat::sweat:。我尝试着在QGIS中通过编写C++插件的方式,增加对VCT格式的支持，:thinking::thinking::thinking:途中发现QGIS拓展数据格式的资料还比较少，所以记下一篇博客，如果有理解不到位的地方，还望及时指出。该小项目的代码见<a target="_blank" rel="noopener" href="https://github.com/Falldio/QgsVctDataProvider/">Github</a>。</p>
<hr>
<p>&lt;%- toc(page.content) %&gt;</p>
<h1 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h1><p>开发环境：VS 2015</p>
<p>Qt版本：5.11.2</p>
<p>QGIS版本：3.12（下载一份源代码和发行版软件，讲道理可以只下载源代码然后自己编译出debug版本的，写插件时输出应该也更方便，但是我太菜了不懂cmake，编译不出来:cry:，就拿源代码去看内部原理，然后把插件写好了放进软件里再测试了:joy:就更加麻烦。​）</p>
<hr>
<p>​        首先，我们在VS 2015的菜单栏点击<code>工具</code>-&gt;<code>扩展和更新</code>，在<code>拓展和更新</code>窗口的左侧选择菜单中选择<code>联机</code>，然后搜索qt，选择搜索结果中的第一项“<em>Qt Visual Studio Tools</em>”，安装完成后重启VS 2015，可以看到菜单栏已经出现了<code>Qt VS Tools</code>，点击<code>Qt VS Tools</code>-&gt;<code>Qt Options</code>，在<code>Qt Versions</code>标签下设置Qt编译器路径，例如，我的就是“<em>C:\Qt\Qt5.11.2\5.11.2\msvc2015</em>”。</p>
<p>​        设置完成之后，我们新建一个项目，模板是<em>Qt Class Library</em>，因为我们要开发的是一个插件，最后生成的是一个dll文件，而非一个带图形界面的应用。:thinking:我们点击菜单栏中的<code>项目</code>-&gt;<code>属性</code>，在属性页中选择<code>C/C++</code>-&gt;<code>常规</code>，选择右侧页面中的<code>附加包含目录</code>，添加QGIS和Qt的库路径，以我为例，路径分别为：</p>
<p>​    <em>C:\Users\lenovo\Desktop\osgeow\apps\Qt5\include\QtGui</em></p>
<p>​    <em>C:\Users\lenovo\Desktop\osgeow\apps\Qt5\include\QtWidgets</em></p>
<p>​    <em>C:\Users\lenovo\Desktop\osgeow\apps\Qt5\include\QtXml</em></p>
<p>​    <em>C:\Users\lenovo\Desktop\osgeow\apps\Qt5\include\QtCore</em></p>
<p>​    <em>C:\Users\lenovo\Desktop\osgeow\apps\qgis\include</em></p>
<p>​    <em>C:\Users\lenovo\Desktop\osgeow\include</em></p>
<p>​    然后点击属性页中的<code>链接器</code>-&gt;<code>常规</code>-&gt;<code>附加库目录</code>，添加QGIS的lib文件路径，例如我的：</p>
<p>​    <em>C:\Users\lenovo\Desktop\osgeow\apps\qgis\lib</em></p>
<p>​        点击<code>输入</code>-&gt;<code>附加依赖项</code>，添加<em>Qt5Xml.lib</em>、<em>Qt5Widgets.lib</em>、<em>qgis_core.lib</em>、<em>qgis_app.lib</em>、<em>qgis_gui.lib</em>。至此，开发环境的配置就大功告成啦!:tada::tada::tada:</p>
<h1 id="2-技术路线"><a href="#2-技术路线" class="headerlink" title="2. 技术路线"></a>2. 技术路线</h1><h2 id="2-1-基类说明"><a href="#2-1-基类说明" class="headerlink" title="2.1 基类说明"></a>2.1 基类说明</h2><p>​        查看源代码可知，QGIS对数据格式的支持是以拓展插件的方式实现的，打开软件之后，QGIS会通过<em>QgsProviderRegistry</em>类扫描<em>Plugin Path</em>下的所有文件（<em>Plugin Path</em>一般位于QGIS目录下的plugins文件夹），找到其中的数据源插件，即各种dll文件中的<em>QgsVectorDataProvider</em>的继承类。因此我们的思路就是自己继承<em>QgsVectorDataProvider</em>，用于链接矢量图层和VCT文件数据源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">QgsProviderRegistry::QgsProviderRegistry( <span class="keyword">const</span> QString &amp;pluginPath )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// At startup, examine the libs in the qgis/lib dir and store those that</span></span><br><span class="line">  <span class="comment">// are a provider shared lib</span></span><br><span class="line">  <span class="comment">// check all libs in the current plugin directory and get name and descriptions</span></span><br><span class="line">  <span class="comment">//TODO figure out how to register and identify data source plugin for a specific</span></span><br><span class="line">  <span class="comment">//TODO layer type</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">char</span> **argv = qApp-&gt;argv();</span><br><span class="line">  QString appDir = argv[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> bin = appDir.findRev( <span class="string">&quot;/bin&quot;</span>, <span class="number">-1</span>, <span class="literal">false</span> );</span><br><span class="line">  QString baseDir = appDir.left( bin );</span><br><span class="line">  QString mLibraryDirectory = baseDir + <span class="string">&quot;/lib&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  mLibraryDirectory.setPath( pluginPath );</span><br><span class="line">  init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        由于没找到相关资料，所以我在类的结构上参考了源代码中的<em>DelimitedText</em>和<em>Memory</em>的结构，代码分别位于QGIS源代码根目录下的“<em>providers\delimitedtext</em>”和“<em>src\core\providers\memory</em>”目录下。我们可以看到，这些插件主要继承了<em>QgsVectorDataProvider</em>、<em>QgsProviderMetadata</em>、<em>QgsAbstractDataSourceWidget</em>、<em>QgsProviderGuiMetadata</em>、<em>QgsSourceSelectProvider</em>、<em>QgsAbstractFeatureSource</em>、*QgsAbstractFeatureIteratorFromSource&lt; T &gt;*等。</p>
<p>​        <em>QgsVectorDataProvider</em>是我们的重点之一，主要负责将矢量文件数据源文件和矢量图层联系起来，文件的读取和要素的改动都通过<em>QgsVectorDataProvider</em>实现。因此我们需要将VCT文件的读写写在这里，后面也可以用代码支持要素的编辑保存。</p>
<p>​        <em>QgsProviderMetadata</em>负责保存<em>QgsVectorDataProvider</em>的key和description，这在<em>QgisApp</em>的初始化中是必要的，QGIS会通过<em>QgsProviderMetadata</em>的createProvider方法来创建我们定义的dataprovider。另外<em>QgsProviderMetadata</em>要求实现的encodeUri和decodeUri方法在对dataprovider的必要参数uri的处理上也很重要，但是在这个例子中我们的uri只是vct文件的储存路径，因此这里不是重点。</p>
<p>​        <em>QgsAbstractDataSourceWidget</em>是QGIS中文件选择框的基类，要实现选择数据源文件，添加相应图层的功能，就必须继承这个接口，继承类主要负责文件选择窗口的用户操作逻辑。<em>QgsProviderGuiMetadata</em>和<em>QgsSourceSelectProvider</em>之间的关系，和前面提到的<em>QgsProviderMetadata</em>与<em>QgsVectorDataProvider</em>的关系相似：<em>QgsProviderGuiMetadata</em>在<em>QgsDataSourceManager</em>初始化时会提供<em>QgsSourceSelectProvider</em>的List，我们自己继承的<em>QgsSourceSelectProvider</em>也是这样创建实例的。而<em>QgsSourceSelectProvider</em>则存放了一些必要的前端说明信息，比如图标，说明文字等，这里也定义了我们自己的窗口在QgsDataSourceManager中同其他窗口的相对顺序。</p>
<p>​        <em>QgsAbstractFeatureSource</em>用于存放我们从文件中读取的要素，<em>QgsAbstractFeatureIteratorFromSource&lt; T &gt;<em>则可以从相应的</em>QgsAbstractFeatureSource</em>实现类中对要素进行遍历等操作。</p>
<p>​        总的来看，用户打开文件选择窗口，选择vct文件，到QGIS添加图层可以分为用户操作和后台响应两块。<em>QgsAbstractDataSourceWidget</em>、<em>QgsProviderGuiMetadata</em>和<em>QgsSourceSelectProvider</em>负责从创建文件选择窗口，并接收用户输入信息。<em>QgsProviderMetadata</em>、<em>QgsVectorDataProvider</em>、<em>QgsAbstractFeatureSource</em>和*QgsAbstractFeatureIteratorFromSource&lt; T &gt;*负责按照将读取到的数据转换成新建矢量图层所必须的信息，同时还可以进一步拓展，支持要素的编辑、空间索引的创建等功能。</p>
<h2 id="2-2-继承类的部分实现"><a href="#2-2-继承类的部分实现" class="headerlink" title="2.2 继承类的部分实现"></a>2.2 继承类的部分实现</h2><p>​        从2.1 基类说明这里，我们可以发现，我们要做的就是分别继承上述几个抽象类，在这几个类里面写自己的逻辑即可。下面是我自己的继承类，以及一些比较重要的，需要实现的方法。</p>
<h3 id="2-2-1-QgsVctProvider"><a href="#2-2-1-QgsVctProvider" class="headerlink" title="2.2.1 QgsVctProvider"></a>2.2.1 QgsVctProvider</h3><img src="/2020/10/25/QGIS%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8B%93%E5%B1%95%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/qgsvctprovider.png" class="" title="QgsVctProvider">

<p>​        <em>QgsVctProvider</em>可以说是这里的主类，首先需要实现<em>QgsVectorDataProvider</em>里面的纯虚函数，包括<em>featureSource</em>、<em>storageType</em>、<em>getFeatures</em>、<em>wkbType</em>、<em>featureCount</em>、<em>fields</em>、<em>capabilities</em>、<em>createSpatialIndex</em>、<em>hasSpatialIndex</em>、<em>name</em>、<em>description</em>、<em>extent</em>、<em>isValid</em>、<em>crs</em>、<em>setSubsetString</em>、<em>supportsSubsetString</em>、<em>subsetString</em>等。这些函数一般都是返回对应图层的某些信息，如空间参考系，要素总数等，根据自己数据格式文件确定即可，然后在<em>capabilities</em>函数中我们需要返回这个dataProvider支持的功能，详见<a target="_blank" rel="noopener" href="https://qgis.org/api/classQgsVectorDataProvider.html#a1a360c9e78933697b9f9be334cfcaf7a">QGIS的官方文档</a>。如果不支持某些功能，在对应的函数里可以直接返回false，比如不支持空间索引创建的话，<em>createSpatialIndex</em>可以直接返回false。由于我们当前的目标是支持文件的读写，所以我们的参数如下面所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QgsVectorDataProvider::Capabilities <span class="title">QgsVctProvider::capabilities</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> AddFeatures | DeleteFeatures | ChangeGeometries |</span><br><span class="line">		ChangeAttributeValues | AddAttributes | DeleteAttributes | RenameAttributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        <em>getFeatures</em>函数将根据特定的请求返回一个<em>QgsFeatureIterator</em>，这个iterator所对应的要素是符合请求条件的全部要素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QgsFeatureIterator <span class="title">QgsVctProvider::getFeatures</span><span class="params">(<span class="keyword">const</span> QgsFeatureRequest &amp;request)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> QgsFeatureIterator(<span class="keyword">new</span> QgsVctFeatureIterator(<span class="keyword">new</span> QgsVctFeatureSource(<span class="keyword">this</span>), <span class="literal">true</span>, request));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        最后我们在构造函数中，还需要先利用<em>setNativeTypes</em>方法设置这个dataProvider支持的字段类型，然后再实现文件的读取，因为当用户选择了一个文件之后，QGIS会直接产生一个对应的<em>dataProvider</em>实例。具体的文件读取代码这里不提，逻辑是<em>QgsVctProvider</em>在构造函数中得到了uri，也就是文件路径（从文件选择窗口得到），然后调用预先写好的<em>writeData</em>方法读取并存放数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">QgsVctProvider::QgsVctProvider(<span class="keyword">const</span> QString &amp;uri, <span class="keyword">const</span> ProviderOptions &amp;options)</span><br><span class="line">	: QgsVectorDataProvider(uri, options)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Add supported types to enable creating expression fields in field calculator</span></span><br><span class="line">	setNativeTypes(QList&lt;NativeType&gt;()</span><br><span class="line">		<span class="comment">//string type</span></span><br><span class="line">		&lt;&lt; QgsVectorDataProvider::NativeType(tr(<span class="string">&quot;Char&quot;</span>), QStringLiteral(<span class="string">&quot;Char&quot;</span>), QVariant::Char, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">		&lt;&lt; QgsVectorDataProvider::NativeType(tr(<span class="string">&quot;Varchar&quot;</span>), QStringLiteral(<span class="string">&quot;Varchar&quot;</span>), QVariant::String, <span class="number">-1</span>, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">//interger types</span></span><br><span class="line">		&lt;&lt; QgsVectorDataProvider::NativeType(tr(<span class="string">&quot;Int1&quot;</span>), QStringLiteral(<span class="string">&quot;Int1&quot;</span>), QVariant::Int, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">		&lt;&lt; QgsVectorDataProvider::NativeType(tr(<span class="string">&quot;Int2&quot;</span>), QStringLiteral(<span class="string">&quot;Int2&quot;</span>), QVariant::Int, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">		&lt;&lt; QgsVectorDataProvider::NativeType(tr(<span class="string">&quot;Int4&quot;</span>), QStringLiteral(<span class="string">&quot;Int4&quot;</span>), QVariant::Int, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">		&lt;&lt; QgsVectorDataProvider::NativeType(tr(<span class="string">&quot;Int8&quot;</span>), QStringLiteral(<span class="string">&quot;Int8&quot;</span>), QVariant::Int, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//floating point</span></span><br><span class="line">		&lt;&lt; QgsVectorDataProvider::NativeType(tr(<span class="string">&quot;Float&quot;</span>), QStringLiteral(<span class="string">&quot;Float&quot;</span>), QVariant::Double, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)</span><br><span class="line">		&lt;&lt; QgsVectorDataProvider::NativeType(tr(<span class="string">&quot;Double&quot;</span>), QStringLiteral(<span class="string">&quot;Double&quot;</span>), QVariant::Double, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">//date types</span></span><br><span class="line">		&lt;&lt; QgsVectorDataProvider::NativeType(tr(<span class="string">&quot;Date&quot;</span>), QStringLiteral(<span class="string">&quot;Date&quot;</span>), QVariant::Date, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)</span><br><span class="line">		&lt;&lt; QgsVectorDataProvider::NativeType(tr(<span class="string">&quot;Time&quot;</span>), QStringLiteral(<span class="string">&quot;Time&quot;</span>), QVariant::Time, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)</span><br><span class="line">		&lt;&lt; QgsVectorDataProvider::NativeType(tr(<span class="string">&quot;Datetime&quot;</span>), QStringLiteral(<span class="string">&quot;Datetime&quot;</span>), QVariant::DateTime, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">//binary type: store file path in a string</span></span><br><span class="line">		&lt;&lt; QgsVectorDataProvider::NativeType(tr(<span class="string">&quot;Varbin&quot;</span>), QStringLiteral(<span class="string">&quot;Varbin&quot;</span>), QVariant::String, <span class="number">-1</span>, <span class="number">-1</span>)</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	mUri = uri;</span><br><span class="line">	readData(mUri);</span><br><span class="line">	mNextFeatureId = featureCount() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-QgsVctFeatureSource"><a href="#2-2-2-QgsVctFeatureSource" class="headerlink" title="2.2.2 QgsVctFeatureSource"></a>2.2.2 QgsVctFeatureSource</h3><img src="/2020/10/25/QGIS%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8B%93%E5%B1%95%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/qgsvctfeaturesource.png" class="" title="QgsVctFeatureSource">

<p>​        <em>QgsVCTFeatureSource</em>中要实现的方法只有构造函数和<em>getFeatures</em>。在构造函数中，<em>我们需要取得QgsVCTProvider</em>中的一些必要数据，比如所有要素，所有字段等。<em>getFeatures</em>返回对应的Iterator类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">QgsVctFeatureSource::QgsVctFeatureSource(<span class="keyword">const</span> QgsVctProvider *p)</span><br><span class="line">	: mExtent(p-&gt;mExtent)</span><br><span class="line">	, mGeometryType(p-&gt;mGeometryType)</span><br><span class="line">	, mCrs(p-&gt;mCrs)</span><br><span class="line">	, mFeatures(p -&gt; mFeatures)</span><br><span class="line">	, mFields(p-&gt;mFields)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QgsFeatureIterator <span class="title">QgsVctFeatureSource::getFeatures</span><span class="params">(<span class="keyword">const</span> QgsFeatureRequest &amp;request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> QgsFeatureIterator(<span class="keyword">new</span> QgsVctFeatureIterator(<span class="keyword">this</span>, <span class="literal">false</span>, request));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-QgsVctFeatureIterator"><a href="#2-2-3-QgsVctFeatureIterator" class="headerlink" title="2.2.3 QgsVctFeatureIterator"></a>2.2.3 QgsVctFeatureIterator</h3><img src="/2020/10/25/QGIS%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8B%93%E5%B1%95%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/qgsvctfeatureiterator.png" class="" title="QgsVctFeatureIterator">

<p>​        <em>QgsVctFeatureIterator</em>中的关键函数为<em>rewind</em>、<em>close</em>和<em>fetchFeature</em>。</p>
<p>​        <em>rewind</em>函数将Iterator的指向重定向为第一个要素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QgsVctFeatureIterator::rewind</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mClosed)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	mSelectIterator = mSource-&gt;mFeatures.constBegin();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        <em>close</em>函数将关闭这个Iterator，当要素的操作出现异常时应该调用这个函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QgsVctFeatureIterator::close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mClosed)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	iteratorClosed();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        <em>fetchFeature</em>函数是为了查看要素集中是否存在要找的要素，QGIS在每一次绘制时似乎都会调用这个方法，我对它的作用还不是很明确。:weary:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QgsVctFeatureIterator::fetchFeature</span><span class="params">(QgsFeature &amp;feature)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	feature.setValid(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (mClosed)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (mSelectIterator != mSource-&gt;mFeatures.constEnd())</span><br><span class="line">	&#123;</span><br><span class="line">		feature = mSelectIterator.value();</span><br><span class="line">		feature.setValid(<span class="literal">true</span>);</span><br><span class="line">		feature.setFields(mSource-&gt;mFields);</span><br><span class="line">		geometryToDestinationCrs(feature, mTransform);</span><br><span class="line">		++mSelectIterator;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		close();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-4-QgsVctProviderMetadata"><a href="#2-2-4-QgsVctProviderMetadata" class="headerlink" title="2.2.4 QgsVctProviderMetadata"></a>2.2.4 QgsVctProviderMetadata</h3><img src="/2020/10/25/QGIS%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8B%93%E5%B1%95%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/qgsvctprovidermetadata.png" class="" title="QgsVctProviderMetadata">

<p>​        <em>QgsVctProviderMetadata</em>中需要对uri进行处理，而由于我在读取vct文件时uri直接是文件路径，因此这里就比较简单，如果是连接数据库等，这里就需要提供请求参数等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QVariantMap <span class="title">QgsVctProviderMetadata::decodeUri</span><span class="params">(<span class="keyword">const</span> QString &amp;uri )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QVariantMap components;</span><br><span class="line">	components.insert(QStringLiteral(<span class="string">&quot;path&quot;</span>), QUrl(uri).toLocalFile());</span><br><span class="line">	<span class="keyword">return</span> components;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">QgsVctProviderMetadata::encodeUri</span><span class="params">(<span class="keyword">const</span> QVariantMap &amp;parts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> QStringLiteral(<span class="string">&quot;file://%1&quot;</span>).arg(parts.value(QStringLiteral(<span class="string">&quot;path&quot;</span>)).toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-5-QgsVctSourceSelectProvider"><a href="#2-2-5-QgsVctSourceSelectProvider" class="headerlink" title="2.2.5 QgsVctSourceSelectProvider"></a>2.2.5 QgsVctSourceSelectProvider</h3><img src="/2020/10/25/QGIS%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8B%93%E5%B1%95%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/qgsvctsourceselectprovider.png" class="" title="QgsVctSourceSelectProvider">

<p>​        在<em>QgsVctSourceSelectProvider</em>中需要实现<em>providerKey</em>、<em>text</em>、<em>ordering</em>、<em>icon</em>和<em>createDataSourceWidget</em>函数。<em>providerKey</em>和<em>text</em>是简单的返回对应的key和说明文字。<em>ordering</em>将定义我们的dataProvider在QgsDataSourceManager窗口中的位置，查看源代码可知QGIS自有顺序的规定。因此，我们相关代码中将顺序定位于<em>OrderLocalProvider</em>之后。这里由于没有设计VCT文件的图标，因此<em>icon</em>这里没返回有意义的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! Provider ordering groups</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Ordering</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  OrderLocalProvider = <span class="number">0</span>, <span class="comment">//!&lt; Starting point for local file providers (e.g. OGR)</span></span><br><span class="line">  OrderDatabaseProvider = <span class="number">1000</span>, <span class="comment">//!&lt; Starting point for database providers (e.g. Postgres)</span></span><br><span class="line">  OrderRemoteProvider = <span class="number">2000</span>, <span class="comment">//!&lt; Starting point for remote (online) providers (e.g. WMS)</span></span><br><span class="line">  OrderGeoCmsProvider = <span class="number">3000</span>, <span class="comment">//!&lt; Starting point for GeoCMS type providers (e.g. GeoNode)</span></span><br><span class="line">  OrderOtherProvider = <span class="number">4000</span>, <span class="comment">//!&lt; Starting point for other providers (e.g. plugin based providers)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ordering</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> QgsSourceSelectProvider::OrderLocalProvider + <span class="number">20</span>; &#125;</span><br><span class="line"><span class="function">QIcon <span class="title">icon</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> QgsApplication::getThemeIcon(QStringLiteral(<span class="string">&quot;&quot;</span>)); &#125;</span><br><span class="line"><span class="function">QgsAbstractDataSourceWidget *<span class="title">createDataSourceWidget</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>, Qt::WindowFlags fl = Qt::Widget, QgsProviderRegistry::WidgetMode widgetMode = QgsProviderRegistry::WidgetMode::Embedded)</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> QgsVctSourceSelect(parent, fl,widgetMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-6-QgsVctProviderMetadata"><a href="#2-2-6-QgsVctProviderMetadata" class="headerlink" title="2.2.6 QgsVctProviderMetadata"></a>2.2.6 QgsVctProviderMetadata</h3><img src="/2020/10/25/QGIS%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8B%93%E5%B1%95%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/qgsvctprovidermetadata.png" class="" title="QgsVctProviderMetadata">

<p>​        <em>QgsVctProviderMetadata</em>中需要注意<em>sourceSelectProviders</em>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QList&lt;QgsSourceSelectProvider *&gt; <span class="title">sourceSelectProviders</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QList&lt;QgsSourceSelectProvider *&gt; providers;</span><br><span class="line">	providers &lt;&lt; <span class="keyword">new</span> QgsVctSourceSelectProvider;</span><br><span class="line">	<span class="keyword">return</span> providers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-7-QgsVctSourceSelect"><a href="#2-2-7-QgsVctSourceSelect" class="headerlink" title="2.2.7 QgsVctSourceSelect"></a>2.2.7 QgsVctSourceSelect</h3><img src="/2020/10/25/QGIS%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8B%93%E5%B1%95%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/qgsvctsourceselect.png" class="" title="QgsVctSourceSelect">

<p>​        <em>QgsVctSourceSelect</em>是我们内嵌在<em>QgsDataSourceManager</em>窗口中的文件选择窗口，我们在这里需要利用Qt Designer设计一个.ui文件，然后利用其命令行工具将ui文件转换为.h文件，然后在我们的类中实现空间的连接和信号处理。.ui文件中一定要有一个QDialogButtonBox控件，以便QGIS在其中放置自己的确认按钮。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QgsVctSourceSelect::QgsVctSourceSelect(QWidget *parent, Qt::WindowFlags fl, QgsProviderRegistry::WidgetMode theWidgetMode)</span><br><span class="line">	: QgsAbstractDataSourceWidget( parent, fl, theWidgetMode )</span><br><span class="line">&#123;</span><br><span class="line">	setupUi(<span class="keyword">this</span>);</span><br><span class="line">	QgsGui::instance()-&gt;enableAutoGeometryRestore(<span class="keyword">this</span>);</span><br><span class="line">	setupButtons(buttonBox);</span><br><span class="line"></span><br><span class="line">	connect(toolButtonFilePath, &amp;QAbstractButton::clicked, <span class="keyword">this</span>, &amp;QgsVctSourceSelect::openFileDialog);</span><br><span class="line">	connect(lineEditFilePath, &amp;QLineEdit::textChanged, <span class="keyword">this</span>, &amp;QgsVctSourceSelect::onFileChanged);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>​        以上内容简单的实现了QGIS中其他矢量数据文件格式的读取，其他的功能，比如创建空间索引、修改要素等功能则需要改变<em>QgsVectorDataProvider</em>的<em>Capability</em>中的返回值，然后按照要求实现指定函数即可。Again，项目的代码见<a target="_blank" rel="noopener" href="https://github.com/Falldio/QgsVctDataProvider/">Github</a>。:tada::tada::tada:</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/10/25/QGIS%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8B%93%E5%B1%95%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/" data-id="ckguq60fb0000vgv35yo71fol" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/25/QGIS%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8B%93%E5%B1%95%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/">QGIS的数据格式拓展插件开发</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>